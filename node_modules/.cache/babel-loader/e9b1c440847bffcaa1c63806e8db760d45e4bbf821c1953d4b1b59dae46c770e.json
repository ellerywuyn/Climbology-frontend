{"ast":null,"code":"var _jsxFileName = \"/Users/yuningwu/Documents/Climbology-frontend/src/components/Create.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport axios from 'axios';\nimport kilter_board from '../assets/kilter_board.png'; // Ensure the path is correct\nimport './Create.css'; // Make sure the CSS file is named correctly and imported\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction KilterBoard() {\n  _s();\n  const [selectedHolds, setSelectedHolds] = useState([]);\n  const [currentHold, setCurrentHold] = useState(null);\n  const [showDropdown, setShowDropdown] = useState(false);\n  const handleClick = async e => {\n    const NUM_GRID_COLUMNS = 35; // Number of columns in the grid\n    const NUM_GRID_ROWS = 38; // Number of rows in the grid\n    const GRID_X_INCREMENT = 1; // Number of pixels between each column\n    const GRID_Y_INCREMENT = 1; // Number of pixels between each row\n    const rect = e.target.getBoundingClientRect();\n    const originalHeight = e.target.naturalHeight;\n    const originalWidth = e.target.naturalWidth;\n    const clickX = e.clientX - rect.left; // X coordinate relative to the image\n    const clickY = e.clientY - rect.top; // Y coordinate relative to the image\n    console.log(\"clickX: \", clickX);\n    console.log(\"clickY: \", clickY);\n    console.log(\"e.clientX: \", e.clientX);\n    console.log(\"e.clientY: \", e.clientY);\n    const cellWidth = rect.width / NUM_GRID_COLUMNS; // Width of one cell\n    const cellHeight = rect.height / NUM_GRID_ROWS; // Height of one cell\n\n    const x = Math.floor(clickX / cellWidth) * GRID_X_INCREMENT;\n    const y = NUM_GRID_ROWS - Math.ceil(clickY / cellHeight) - 1;\n    setCurrentHold({\n      x_coor: e.clientX,\n      y_coor: e.clientY,\n      holdType: 'default' // default hold type\n    });\n    setShowDropdown(true);\n    try {\n      // Update this URL to the correct endpoint\n      const url = 'http://localhost:8000/create/identify_hold/';\n      const response = await axios.post(url, {\n        x,\n        y\n      });\n      if (response.data.success) {\n        const holdX = response.data.x_coordinate;\n        const holdY = response.data.y_coordinate;\n\n        // Convert grid coordinates back to pixel coordinates\n        const pixelX = holdX * cellWidth + cellWidth / 2;\n        const pixelY = (NUM_GRID_ROWS - holdY - 1) * cellHeight + cellHeight / 2;\n        setSelectedHolds([...selectedHolds, {\n          id: response.data.holdId,\n          x_grid: response.data.x_coordinate,\n          y_grid: response.data.y_coordinate,\n          x_coor: e.clientX,\n          y_coor: e.clientY,\n          hold_type: response.data.type,\n          hold_function: response.data.function,\n          hold_depth: response.data.depth,\n          hold_orientation: response.data.orientation\n        }]);\n        // console.log('Hold identified:', response.data.holdId, response.data.x_coordinate, response.data.y_coordinate, pixelX, pixelY);\n        // console.log('Hold identified:', selectedHolds);\n        // pass to selectedHolds to backend\n      } else {\n        console.error('No hold identified:', response.data.message);\n      }\n    } catch (error) {\n      console.error('Error when identifying hold:', error);\n    }\n  };\n  useEffect(() => {\n    console.log('Updated Holds:', selectedHolds);\n  }, [selectedHolds]);\n  const updateHoldType = holdType => {\n    if (currentHold) {\n      setSelectedHolds([...selectedHolds, {\n        ...currentHold,\n        holdType: holdType\n      }]);\n    }\n  };\n  const renderCircles = () => {\n    return selectedHolds.map((hold, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"circle\",\n      style: {\n        top: hold.y_coor,\n        left: hold.x_coor,\n        borderColor: getCircleColor(hold.holdType)\n      }\n    }, index, false, {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 13\n    }, this));\n  };\n  const getCircleColor = holdType => {\n    switch (holdType) {\n      case 'Start':\n        return 'green';\n      case 'Middle':\n        return 'blue';\n      case 'End':\n        return 'purple';\n      case 'Foot Only':\n        return 'orange';\n      default:\n        return 'red';\n    }\n  };\n  const DropdownMenu = ({\n    currentHold,\n    updateHoldType\n  }) => {\n    const handleSelection = holdType => {\n      updateHoldType(holdType);\n      setShowDropdown(false); // Hide dropdown after selection\n    };\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"dropdown-menu\",\n      style: {\n        top: currentHold.y_coor,\n        left: currentHold.x_coor + 50\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => handleSelection('Start'),\n        children: \"Start\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 123,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => handleSelection('Middle'),\n        children: \"Middle\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 124,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => handleSelection('End'),\n        children: \"End\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 125,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => handleSelection('Foot Only'),\n        children: \"Foot Only\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 13\n    }, this);\n  };\n  // return (\n  //     <div className=\"kilterBoardContainer\">\n  //         <img src={kilter_board} alt=\"Kilter Board\" className=\"kilter-board\" onClick={handleClick} />\n  //         {renderCircles()}\n  //     </div>\n  // );\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"kilterBoardContainer\",\n    children: [/*#__PURE__*/_jsxDEV(\"img\", {\n      src: kilter_board,\n      alt: \"Kilter Board\",\n      className: \"kilter-board\",\n      onClick: handleClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 13\n    }, this), renderCircles(), showDropdown && currentHold && /*#__PURE__*/_jsxDEV(DropdownMenu, {\n      currentHold: currentHold,\n      updateHoldType: updateHoldType\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 141,\n      columnNumber: 45\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 138,\n    columnNumber: 9\n  }, this);\n}\n_s(KilterBoard, \"494SYZxKfy78acg/e3w+9GnHjxA=\");\n_c = KilterBoard;\nexport default KilterBoard;\n\n// function KilterBoard() {\n//     const [selectedHolds, setSelectedHolds] = useState([]);\n\n//     const handleClick = async (e) => {\n//         const NUM_GRID_COLUMNS = 35; // Number of columns in the grid\n//         const NUM_GRID_ROWS = 38; // Number of rows in the grid\n//         const GRID_X_INCREMENT = 1; // Number of pixels between each column\n//         const GRID_Y_INCREMENT = 1; // Number of pixels between each row\n//         const rect = e.target.getBoundingClientRect();\n\n//         const originalHeight = e.target.naturalHeight;\n//         const originalWidth = e.target.naturalWidth;\n\n//         // Scaling factor\n//         // const scaleY = rect.height / originalHeight;\n//         // const scaleX = rect.width / originalWidth;\n\n//         // const clickX = (e.clientX - rect.left) / scaleX;\n//         // const clickY = (e.clientY - rect.top) / scaleY;\n\n//         // const clickX1 = e.clientX/ scaleX;\n//         // const clickY1 = e.clientY/ scaleY;\n\n//         const clickX = e.clientX - rect.left; // X coordinate relative to the image\n//         const clickY = e.clientY - rect.top; // Y coordinate relative to the image\n//         console.log(\"clickX: \", clickX);\n//         console.log(\"clickY: \", clickY);\n//         console.log(\"e.clientX: \", e.clientX);\n//         console.log(\"e.clientY: \", e.clientY);\n//         const cellWidth = rect.width / NUM_GRID_COLUMNS; // Width of one cell\n//         const cellHeight = rect.height / NUM_GRID_ROWS; // Height of one cell\n\n//         const x = Math.floor(clickX / cellWidth) * GRID_X_INCREMENT;\n//         const y = NUM_GRID_ROWS - Math.ceil(clickY / cellHeight) -1;\n\n//         try {\n//             // Update this URL to the correct endpoint\n//             const url = 'http://localhost:8000/create/identify_hold/';\n\n//             const response = await axios.post(url, { x, y });\n\n//             if (response.data.success) {\n//                 const holdX = response.data.x_coordinate;\n//                 const holdY = response.data.y_coordinate;\n\n//                 // Convert grid coordinates back to pixel coordinates\n//                 const pixelX = holdX * cellWidth + cellWidth / 2;\n//                 const pixelY = (NUM_GRID_ROWS - holdY - 1) * cellHeight + cellHeight / 2;\n\n//                 setSelectedHolds([...selectedHolds, {\n//                     id: response.data.holdId,\n//                     x_grid: response.data.x_coordinate,\n//                     y_grid: response.data.y_coordinate,\n//                     x_coor: e.clientX,\n//                     y_coor: e.clientY,\n//                     hold_type: response.data.type,\n//                     hold_function: response.data.function,\n//                     hold_depth: response.data.depth,\n//                     hold_orientation: response.data.orientation,\n//                     hold_size: response.data.size\n\n//                     // x_coor: clickX,\n//                     // y_coor: clickY\n//                     // x_coor: pixelX,\n//                     // y_coor: pixelY\n//                     // x_coor: clickX1,\n//                     // y_coor: clickY1\n//                 }]);\n//                 // console.log('Hold identified:', response.data.holdId, response.data.x_coordinate, response.data.y_coordinate, pixelX, pixelY);\n//                 console.log('Hold identified:', selectedHolds);\n//                 // pass to selectedHolds to backend\n\n//             } else {\n//                 console.error('No hold identified:', response.data.message);\n//             }\n//         } catch (error) {\n//             console.error('Error when identifying hold:', error);\n//         }\n//     };\n\n//     // Function to render circles on selected holds\n//     const renderCircles = () => {\n//         return selectedHolds.map(hold => (\n//             <div \n//                 key={hold.id} \n//                 className=\"circle\" \n//                 style={{ top: hold.y_coor, left: hold.x_coor }} \n//                 // style = {{top: clickX, left: e.clientX}}\n//             />\n//         ));\n//     };\n\n//     return (\n//         <div className=\"kilterBoardContainer\">\n//             <img src={kilter_board} alt=\"Kilter Board\" className=\"kilter-board\" onClick={handleClick} />\n//             {renderCircles()}\n//         </div>\n//     );\n// }\n\n// export default KilterBoard;\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// const Board = ({ numberOfRows, numberOfColumns }) => {\n//   const [selectedHold, setSelectedHold] = useState('');\n//   const boardRef = useRef();\n\n//   const handleBoardClick = async (event) => {\n//     const board = boardRef.current;\n//     const rect = board.getBoundingClientRect();\n//     const scaleX = board.width / rect.width;   // relationship bitmap vs. element for X\n//     const scaleY = board.height / rect.height; // relationship bitmap vs. element for Y\n\n//     const gridX = Math.ceil((event.clientX - rect.left) * scaleX / (board.width / numberOfColumns));\n//     const gridY = Math.ceil((event.clientY - rect.top) * scaleY / (board.height / numberOfRows));\n\n//     const holdLabel = `${String.fromCharCode(64 + gridY)}${gridX}`;\n//     setSelectedHold(holdLabel);\n//     try {\n//         // Update this URL to the correct endpoint\n//         const url = 'http://localhost:8000/create/identify_hold/';\n\n//         const response = await axios.post(url, { gridX, gridY });\n\n//         if (response.data.success) {\n//             setSelectedHold([...selectedHold, {\n//                 id: response.data.holdId,\n//                 x: response.data.x_coordinate,\n//                 y: response.data.y_coordinate\n//             }])\n//             console.log('Hold identified:', response.data.holdId);\n//         } else {\n//             console.error('No hold identified:', response.data.message);\n//         }\n//     } catch (error) {\n//         console.error('Error when identifying hold:', error);\n//     }\n// };\n\n//   return (\n//     <div>\n//       <img\n//         ref={boardRef}\n//         src={kilter_board}\n//         alt=\"Kilter Board\"\n//         onClick={handleBoardClick}\n//       />\n//       {selectedHold && <p>Selected Hold: {selectedHold}</p>}\n//     </div>\n//   );\n// };\n\n// export default Board;\n\n// function KilterBoard() {\n//     const [selectedHolds, setSelectedHolds] = useState([]);\n\n//     const handleClick = async (e) => {\n//         const NUM_GRID_COLUMNS = 35; // Number of columns in the grid\n//         const NUM_GRID_ROWS = 38; // Number of rows in the grid\n//         const GRID_X_INCREMENT = 1; // Number of pixels between each column\n//         const GRID_Y_INCREMENT = 1; // Number of pixels between each row\n//         const rect = e.target.getBoundingClientRect();\n//         const clickX = e.clientX - rect.left; // X coordinate relative to the image\n//         const clickY = e.clientY - rect.top; // Y coordinate relative to the image\n\n//         const cellWidth = rect.width / NUM_GRID_COLUMNS; // Width of one cell\n//         const cellHeight = rect.height / NUM_GRID_ROWS; // Height of one cell\n\n//         const gridX = Math.floor(clickX / cellWidth) * GRID_X_INCREMENT;\n//         // const gridY = Math.floor(clickY / cellHeight) * GRID_Y_INCREMENT;\n//         const gridY = (NUM_GRID_ROWS - 1 - Math.floor(clickY / cellHeight)) * GRID_Y_INCREMENT;\n\n//         try {\n//             // Update this URL to the correct endpoint\n//             const url = 'http://localhost:8000/create/identify_hold/';\n\n//             const response = await axios.post(url, { gridX, gridY });\n\n//             if (response.data.success) {\n//                 setSelectedHolds([...selectedHolds, {\n//                     id: response.data.holdId,\n//                     x: response.data.x_coordinate,\n//                     y: response.data.y_coordinate\n//                 }])\n//                 console.log('Hold identified:', response.data.holdId);\n//             } else {\n//                 console.error('No hold identified:', response.data.message);\n//             }\n//         } catch (error) {\n//             console.error('Error when identifying hold:', error);\n//         }\n//     };\n\n//     // const handleClick = async (e) => {\n//     //     const rect = e.target.getBoundingClientRect();\n//     //     const x = e.clientX - rect.left; // x coordinate relative to the image\n//     //     const y = e.clientY - rect.top; // y coordinate relative to the image\n\n//     //     try {\n//     //         // Update this URL to the correct endpoint\n//     //         const url = 'http://localhost:8000/create/identify_hold/';\n\n//     //         const response = await axios.post(url, { x, y });\n\n//     //         if (response.data.success) {\n//     //             setSelectedHolds([...selectedHolds, {\n//     //                 id: response.data.holdId,\n//     //                 x: response.data.x_coordinate,\n//     //                 y: response.data.y_coordinate\n//     //             }])\n//     //             console.log('Hold identified:', response.data.holdId);\n//     //         } else {\n//     //             console.error('No hold identified:', response.data.message);\n//     //         }\n//     //     } catch (error) {\n//     //         console.error('Error when identifying hold:', error);\n//     //     }\n//     // };\n\n//     // Function to render circles on selected holds\n//     const renderCircles = () => {\n//         return selectedHolds.map(hold => (\n//             <div \n//                 key={hold.id} \n//                 className=\"circle\" \n//                 style={{ top: hold.y, left: hold.x }} \n//             />\n//         ));\n//     };\n\n//     return (\n//         <div className=\"kilterBoardContainer\">\n//             <img src={kilter_board} alt=\"Kilter Board\" className=\"kilter-board\" onClick={handleClick} />\n//             {renderCircles()}\n//         </div>\n//     );\n// }\n\n// export default KilterBoard;\n\n// // import './Create.css'; // Make sure the CSS file is named correctly and imported\n// // import kilter_board from '../assets/kilter_board.png';\n// // import React, { useState } from 'react';\n// // import axios from 'axios';\n\n// // function Create() {\n// //     const [selectedHolds, setSelectedHolds] = useState([]);\n// //     // ... previous code ...\n\n// //     const renderCircles = () => {\n// //         return selectedHolds.map(hold => (\n// //         <div \n// //             key={hold.id} \n// //             className=\"circle\" \n// //             style={{ top: hold.y, left: hold.x }} \n// //         />\n// //         ));\n// //     };\n\n// //     const handleClick = async (e) => {\n// //         const rect = e.target.getBoundingClientRect();\n// //         const x = e.clientX - rect.left;\n// //         const y = e.clientY - rect.top;\n\n// //         const response = await axios.post('/api/identify-hold', { x, y });\n// //         if (response.data.success) {\n// //         setSelectedHolds([...selectedHolds, response.data.holdId]);\n// //         }\n// //     };\n\n// //     // return (\n// //     //     <img src={kilter_board} alt=\"kilter board\" className=\"kilter-board\" onClick={handleClick} />\n// //     // );\n\n// //     return (\n// //     <div className=\"kilterBoardContainer\">\n// //         <img src={kilter_board} alt=\"kilter board\" className=\"kilter-board\" onClick={handleClick} />\n// //         {renderCircles()}\n// //     </div>\n// //     );\n// // }\n\n// // export default Create;\n\n// //   return (\n// //     <main className=\"create-route\">\n// //       <h1>Climbology</h1>\n// //       <div className=\"content-area\">\n// //           <img src={kilter_board} alt=\"kilter board\" className=\"kilter-board\" />\n// //       </div>\n// //     </main>\n// //   );\n\n// const gridY = Math.floor(clickY / cellHeight) * GRID_Y_INCREMENT;\n// const y = (NUM_GRID_ROWS - 1 - Math.floor(clickY / cellHeight)) * GRID_Y_INCREMENT;\n// const rect = e.target.getBoundingClientRect();\n// const x = e.clientX - rect.left; // x coordinate relative to the image\n// const y = e.clientY - rect.top; // y coordinate relative to the image\nvar _c;\n$RefreshReg$(_c, \"KilterBoard\");","map":{"version":3,"names":["React","useState","useRef","useEffect","axios","kilter_board","jsxDEV","_jsxDEV","KilterBoard","_s","selectedHolds","setSelectedHolds","currentHold","setCurrentHold","showDropdown","setShowDropdown","handleClick","e","NUM_GRID_COLUMNS","NUM_GRID_ROWS","GRID_X_INCREMENT","GRID_Y_INCREMENT","rect","target","getBoundingClientRect","originalHeight","naturalHeight","originalWidth","naturalWidth","clickX","clientX","left","clickY","clientY","top","console","log","cellWidth","width","cellHeight","height","x","Math","floor","y","ceil","x_coor","y_coor","holdType","url","response","post","data","success","holdX","x_coordinate","holdY","y_coordinate","pixelX","pixelY","id","holdId","x_grid","y_grid","hold_type","type","hold_function","function","hold_depth","depth","hold_orientation","orientation","error","message","updateHoldType","renderCircles","map","hold","index","className","style","borderColor","getCircleColor","fileName","_jsxFileName","lineNumber","columnNumber","DropdownMenu","handleSelection","children","onClick","src","alt","_c","$RefreshReg$"],"sources":["/Users/yuningwu/Documents/Climbology-frontend/src/components/Create.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport axios from 'axios';\nimport kilter_board from '../assets/kilter_board.png'; // Ensure the path is correct\nimport './Create.css'; // Make sure the CSS file is named correctly and imported\n\nfunction KilterBoard() {\n    const [selectedHolds, setSelectedHolds] = useState([]);\n    const [currentHold, setCurrentHold] = useState(null);\n    const [showDropdown, setShowDropdown] = useState(false);\n    \n    const handleClick = async (e) => {\n        const NUM_GRID_COLUMNS = 35; // Number of columns in the grid\n        const NUM_GRID_ROWS = 38; // Number of rows in the grid\n        const GRID_X_INCREMENT = 1; // Number of pixels between each column\n        const GRID_Y_INCREMENT = 1; // Number of pixels between each row\n        const rect = e.target.getBoundingClientRect();\n\n        const originalHeight = e.target.naturalHeight;\n        const originalWidth = e.target.naturalWidth;\n\n        const clickX = e.clientX - rect.left; // X coordinate relative to the image\n        const clickY = e.clientY - rect.top; // Y coordinate relative to the image\n        console.log(\"clickX: \", clickX);\n        console.log(\"clickY: \", clickY);\n        console.log(\"e.clientX: \", e.clientX);\n        console.log(\"e.clientY: \", e.clientY);\n        const cellWidth = rect.width / NUM_GRID_COLUMNS; // Width of one cell\n        const cellHeight = rect.height / NUM_GRID_ROWS; // Height of one cell\n    \n        const x = Math.floor(clickX / cellWidth) * GRID_X_INCREMENT;\n        const y = NUM_GRID_ROWS - Math.ceil(clickY / cellHeight) -1;\n        setCurrentHold({\n            x_coor: e.clientX,\n            y_coor: e.clientY,\n            holdType: 'default', // default hold type\n        });\n        setShowDropdown(true);\n\n        try {\n            // Update this URL to the correct endpoint\n            const url = 'http://localhost:8000/create/identify_hold/';\n            \n            const response = await axios.post(url, { x, y });\n            \n            if (response.data.success) {\n                const holdX = response.data.x_coordinate;\n                const holdY = response.data.y_coordinate;\n\n                // Convert grid coordinates back to pixel coordinates\n                const pixelX = holdX * cellWidth + cellWidth / 2;\n                const pixelY = (NUM_GRID_ROWS - holdY - 1) * cellHeight + cellHeight / 2;\n\n                setSelectedHolds([...selectedHolds, {\n                    id: response.data.holdId,\n                    x_grid: response.data.x_coordinate,\n                    y_grid: response.data.y_coordinate,\n                    x_coor: e.clientX,\n                    y_coor: e.clientY,\n                    hold_type: response.data.type,\n                    hold_function: response.data.function,\n                    hold_depth: response.data.depth,\n                    hold_orientation: response.data.orientation,\n                }]);\n                // console.log('Hold identified:', response.data.holdId, response.data.x_coordinate, response.data.y_coordinate, pixelX, pixelY);\n                // console.log('Hold identified:', selectedHolds);\n                // pass to selectedHolds to backend\n\n            } else {\n                console.error('No hold identified:', response.data.message);\n            }\n        } catch (error) {\n            console.error('Error when identifying hold:', error);\n        }\n    };\n\n    useEffect(() => {\n        console.log('Updated Holds:', selectedHolds);\n    }, [selectedHolds]);\n    \n    const updateHoldType = (holdType) => {\n        if (currentHold) {\n            setSelectedHolds([\n                ...selectedHolds,\n                { ...currentHold, holdType: holdType }\n            ]);\n        }\n    };\n\n    const renderCircles = () => {\n        return selectedHolds.map((hold, index) => (\n            <div \n                key={index}\n                className=\"circle\"\n                style={{\n                    top: hold.y_coor,\n                    left: hold.x_coor,\n                    borderColor: getCircleColor(hold.holdType),\n                }}\n            />\n        ));\n    };\n    \n    const getCircleColor = (holdType) => {\n        switch (holdType) {\n            case 'Start': return 'green';\n            case 'Middle': return 'blue';\n            case 'End': return 'purple';\n            case 'Foot Only': return 'orange';\n            default: return 'red';\n        }\n    };\n\n    \n    \n    const DropdownMenu = ({ currentHold, updateHoldType }) => {\n        const handleSelection = (holdType) => {\n            updateHoldType(holdType);\n            setShowDropdown(false); // Hide dropdown after selection\n        };\n    \n        return (\n            <div className=\"dropdown-menu\" style={{ top: currentHold.y_coor, left: currentHold.x_coor + 50 }}>\n                <button onClick={() => handleSelection('Start')}>Start</button>\n                <button onClick={() => handleSelection('Middle')}>Middle</button>\n                <button onClick={() => handleSelection('End')}>End</button>\n                <button onClick={() => handleSelection('Foot Only')}>Foot Only</button>\n            </div>\n        );\n    };\n    // return (\n    //     <div className=\"kilterBoardContainer\">\n    //         <img src={kilter_board} alt=\"Kilter Board\" className=\"kilter-board\" onClick={handleClick} />\n    //         {renderCircles()}\n    //     </div>\n    // );\n\n    return (\n        <div className=\"kilterBoardContainer\">\n            <img src={kilter_board} alt=\"Kilter Board\" className=\"kilter-board\" onClick={handleClick} />\n            {renderCircles()}\n            {showDropdown && currentHold && <DropdownMenu currentHold={currentHold} updateHoldType={updateHoldType} />}\n        </div>\n    );\n    \n}\n\nexport default KilterBoard;\n\n\n\n// function KilterBoard() {\n//     const [selectedHolds, setSelectedHolds] = useState([]);\n    \n//     const handleClick = async (e) => {\n//         const NUM_GRID_COLUMNS = 35; // Number of columns in the grid\n//         const NUM_GRID_ROWS = 38; // Number of rows in the grid\n//         const GRID_X_INCREMENT = 1; // Number of pixels between each column\n//         const GRID_Y_INCREMENT = 1; // Number of pixels between each row\n//         const rect = e.target.getBoundingClientRect();\n\n//         const originalHeight = e.target.naturalHeight;\n//         const originalWidth = e.target.naturalWidth;\n    \n//         // Scaling factor\n//         // const scaleY = rect.height / originalHeight;\n//         // const scaleX = rect.width / originalWidth;\n    \n//         // const clickX = (e.clientX - rect.left) / scaleX;\n//         // const clickY = (e.clientY - rect.top) / scaleY;\n\n//         // const clickX1 = e.clientX/ scaleX;\n//         // const clickY1 = e.clientY/ scaleY;\n    \n\n//         const clickX = e.clientX - rect.left; // X coordinate relative to the image\n//         const clickY = e.clientY - rect.top; // Y coordinate relative to the image\n//         console.log(\"clickX: \", clickX);\n//         console.log(\"clickY: \", clickY);\n//         console.log(\"e.clientX: \", e.clientX);\n//         console.log(\"e.clientY: \", e.clientY);\n//         const cellWidth = rect.width / NUM_GRID_COLUMNS; // Width of one cell\n//         const cellHeight = rect.height / NUM_GRID_ROWS; // Height of one cell\n    \n//         const x = Math.floor(clickX / cellWidth) * GRID_X_INCREMENT;\n//         const y = NUM_GRID_ROWS - Math.ceil(clickY / cellHeight) -1;\n\n\n\n//         try {\n//             // Update this URL to the correct endpoint\n//             const url = 'http://localhost:8000/create/identify_hold/';\n            \n//             const response = await axios.post(url, { x, y });\n            \n//             if (response.data.success) {\n//                 const holdX = response.data.x_coordinate;\n//                 const holdY = response.data.y_coordinate;\n\n//                 // Convert grid coordinates back to pixel coordinates\n//                 const pixelX = holdX * cellWidth + cellWidth / 2;\n//                 const pixelY = (NUM_GRID_ROWS - holdY - 1) * cellHeight + cellHeight / 2;\n\n//                 setSelectedHolds([...selectedHolds, {\n//                     id: response.data.holdId,\n//                     x_grid: response.data.x_coordinate,\n//                     y_grid: response.data.y_coordinate,\n//                     x_coor: e.clientX,\n//                     y_coor: e.clientY,\n//                     hold_type: response.data.type,\n//                     hold_function: response.data.function,\n//                     hold_depth: response.data.depth,\n//                     hold_orientation: response.data.orientation,\n//                     hold_size: response.data.size\n\n//                     // x_coor: clickX,\n//                     // y_coor: clickY\n//                     // x_coor: pixelX,\n//                     // y_coor: pixelY\n//                     // x_coor: clickX1,\n//                     // y_coor: clickY1\n//                 }]);\n//                 // console.log('Hold identified:', response.data.holdId, response.data.x_coordinate, response.data.y_coordinate, pixelX, pixelY);\n//                 console.log('Hold identified:', selectedHolds);\n//                 // pass to selectedHolds to backend\n\n//             } else {\n//                 console.error('No hold identified:', response.data.message);\n//             }\n//         } catch (error) {\n//             console.error('Error when identifying hold:', error);\n//         }\n//     };\n\n//     // Function to render circles on selected holds\n//     const renderCircles = () => {\n//         return selectedHolds.map(hold => (\n//             <div \n//                 key={hold.id} \n//                 className=\"circle\" \n//                 style={{ top: hold.y_coor, left: hold.x_coor }} \n//                 // style = {{top: clickX, left: e.clientX}}\n//             />\n//         ));\n//     };\n\n//     return (\n//         <div className=\"kilterBoardContainer\">\n//             <img src={kilter_board} alt=\"Kilter Board\" className=\"kilter-board\" onClick={handleClick} />\n//             {renderCircles()}\n//         </div>\n//     );\n// }\n\n// export default KilterBoard;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// const Board = ({ numberOfRows, numberOfColumns }) => {\n//   const [selectedHold, setSelectedHold] = useState('');\n//   const boardRef = useRef();\n\n//   const handleBoardClick = async (event) => {\n//     const board = boardRef.current;\n//     const rect = board.getBoundingClientRect();\n//     const scaleX = board.width / rect.width;   // relationship bitmap vs. element for X\n//     const scaleY = board.height / rect.height; // relationship bitmap vs. element for Y\n\n//     const gridX = Math.ceil((event.clientX - rect.left) * scaleX / (board.width / numberOfColumns));\n//     const gridY = Math.ceil((event.clientY - rect.top) * scaleY / (board.height / numberOfRows));\n    \n//     const holdLabel = `${String.fromCharCode(64 + gridY)}${gridX}`;\n//     setSelectedHold(holdLabel);\n//     try {\n//         // Update this URL to the correct endpoint\n//         const url = 'http://localhost:8000/create/identify_hold/';\n        \n//         const response = await axios.post(url, { gridX, gridY });\n        \n//         if (response.data.success) {\n//             setSelectedHold([...selectedHold, {\n//                 id: response.data.holdId,\n//                 x: response.data.x_coordinate,\n//                 y: response.data.y_coordinate\n//             }])\n//             console.log('Hold identified:', response.data.holdId);\n//         } else {\n//             console.error('No hold identified:', response.data.message);\n//         }\n//     } catch (error) {\n//         console.error('Error when identifying hold:', error);\n//     }\n// };\n\n//   return (\n//     <div>\n//       <img\n//         ref={boardRef}\n//         src={kilter_board}\n//         alt=\"Kilter Board\"\n//         onClick={handleBoardClick}\n//       />\n//       {selectedHold && <p>Selected Hold: {selectedHold}</p>}\n//     </div>\n//   );\n// };\n\n// export default Board;\n\n\n\n\n\n\n// function KilterBoard() {\n//     const [selectedHolds, setSelectedHolds] = useState([]);\n\n    \n\n//     const handleClick = async (e) => {\n//         const NUM_GRID_COLUMNS = 35; // Number of columns in the grid\n//         const NUM_GRID_ROWS = 38; // Number of rows in the grid\n//         const GRID_X_INCREMENT = 1; // Number of pixels between each column\n//         const GRID_Y_INCREMENT = 1; // Number of pixels between each row\n//         const rect = e.target.getBoundingClientRect();\n//         const clickX = e.clientX - rect.left; // X coordinate relative to the image\n//         const clickY = e.clientY - rect.top; // Y coordinate relative to the image\n    \n//         const cellWidth = rect.width / NUM_GRID_COLUMNS; // Width of one cell\n//         const cellHeight = rect.height / NUM_GRID_ROWS; // Height of one cell\n    \n//         const gridX = Math.floor(clickX / cellWidth) * GRID_X_INCREMENT;\n//         // const gridY = Math.floor(clickY / cellHeight) * GRID_Y_INCREMENT;\n//         const gridY = (NUM_GRID_ROWS - 1 - Math.floor(clickY / cellHeight)) * GRID_Y_INCREMENT;\n\n    \n//         try {\n//             // Update this URL to the correct endpoint\n//             const url = 'http://localhost:8000/create/identify_hold/';\n            \n//             const response = await axios.post(url, { gridX, gridY });\n            \n//             if (response.data.success) {\n//                 setSelectedHolds([...selectedHolds, {\n//                     id: response.data.holdId,\n//                     x: response.data.x_coordinate,\n//                     y: response.data.y_coordinate\n//                 }])\n//                 console.log('Hold identified:', response.data.holdId);\n//             } else {\n//                 console.error('No hold identified:', response.data.message);\n//             }\n//         } catch (error) {\n//             console.error('Error when identifying hold:', error);\n//         }\n//     };\n\n    \n//     // const handleClick = async (e) => {\n//     //     const rect = e.target.getBoundingClientRect();\n//     //     const x = e.clientX - rect.left; // x coordinate relative to the image\n//     //     const y = e.clientY - rect.top; // y coordinate relative to the image\n\n//     //     try {\n//     //         // Update this URL to the correct endpoint\n//     //         const url = 'http://localhost:8000/create/identify_hold/';\n            \n//     //         const response = await axios.post(url, { x, y });\n            \n//     //         if (response.data.success) {\n//     //             setSelectedHolds([...selectedHolds, {\n//     //                 id: response.data.holdId,\n//     //                 x: response.data.x_coordinate,\n//     //                 y: response.data.y_coordinate\n//     //             }])\n//     //             console.log('Hold identified:', response.data.holdId);\n//     //         } else {\n//     //             console.error('No hold identified:', response.data.message);\n//     //         }\n//     //     } catch (error) {\n//     //         console.error('Error when identifying hold:', error);\n//     //     }\n//     // };\n\n//     // Function to render circles on selected holds\n//     const renderCircles = () => {\n//         return selectedHolds.map(hold => (\n//             <div \n//                 key={hold.id} \n//                 className=\"circle\" \n//                 style={{ top: hold.y, left: hold.x }} \n//             />\n//         ));\n//     };\n\n//     return (\n//         <div className=\"kilterBoardContainer\">\n//             <img src={kilter_board} alt=\"Kilter Board\" className=\"kilter-board\" onClick={handleClick} />\n//             {renderCircles()}\n//         </div>\n//     );\n// }\n\n// export default KilterBoard;\n\n\n\n// // import './Create.css'; // Make sure the CSS file is named correctly and imported\n// // import kilter_board from '../assets/kilter_board.png';\n// // import React, { useState } from 'react';\n// // import axios from 'axios';\n\n// // function Create() {\n// //     const [selectedHolds, setSelectedHolds] = useState([]);\n// //     // ... previous code ...\n\n// //     const renderCircles = () => {\n// //         return selectedHolds.map(hold => (\n// //         <div \n// //             key={hold.id} \n// //             className=\"circle\" \n// //             style={{ top: hold.y, left: hold.x }} \n// //         />\n// //         ));\n// //     };\n\n// //     const handleClick = async (e) => {\n// //         const rect = e.target.getBoundingClientRect();\n// //         const x = e.clientX - rect.left;\n// //         const y = e.clientY - rect.top;\n    \n// //         const response = await axios.post('/api/identify-hold', { x, y });\n// //         if (response.data.success) {\n// //         setSelectedHolds([...selectedHolds, response.data.holdId]);\n// //         }\n// //     };\n    \n// //     // return (\n// //     //     <img src={kilter_board} alt=\"kilter board\" className=\"kilter-board\" onClick={handleClick} />\n// //     // );\n      \n// //     return (\n// //     <div className=\"kilterBoardContainer\">\n// //         <img src={kilter_board} alt=\"kilter board\" className=\"kilter-board\" onClick={handleClick} />\n// //         {renderCircles()}\n// //     </div>\n// //     );\n// // }\n\n\n// // export default Create;\n\n\n// //   return (\n// //     <main className=\"create-route\">\n// //       <h1>Climbology</h1>\n// //       <div className=\"content-area\">\n// //           <img src={kilter_board} alt=\"kilter board\" className=\"kilter-board\" />\n// //       </div>\n// //     </main>\n// //   );\n\n        // const gridY = Math.floor(clickY / cellHeight) * GRID_Y_INCREMENT;\n        // const y = (NUM_GRID_ROWS - 1 - Math.floor(clickY / cellHeight)) * GRID_Y_INCREMENT;\n                // const rect = e.target.getBoundingClientRect();\n        // const x = e.clientX - rect.left; // x coordinate relative to the image\n        // const y = e.clientY - rect.top; // y coordinate relative to the image"],"mappings":"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AAIF,WAAW,iBAAIL,OAAA,CAACgF,YAAY;MAAC3E,WAAW,EAAEA,WAAY;MAAC8D,cAAc,EAAEA;IAAe;MAAAS,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACzG,CAAC;AAGd;AAAC7E,EAAA,CA3IQD,WAAW;AAAAqF,EAAA,GAAXrF,WAAW;AA6IpB,eAAeA,WAAW;;AAI1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAiBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAOA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEQ;AACA;AACQ;AACR;AACA;AAAA,IAAAqF,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}